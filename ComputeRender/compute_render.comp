//!#version 440
#define COMPUTE 1
layout(local_size_x=16, local_size_y=16, local_size_z = 1) in;
#include "../raytracer.glsl"
layout(rgba32f, binding=0) uniform image2D colorOutput;
layout(rgba8, binding=1) uniform image2D normalsBuffer;
layout(r32f, binding=2) uniform image2D depthBuffer;

void main()
{
	ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
	int sampleNum = floatBitsToInt(HQSettings_sampleNum);
	int indirectSamples /*per every direct*/ = floatBitsToInt(Multisampling_indirect);
	int directSampleNum = sampleNum / indirectSamples;
	if(sampleNum == 0)
	{
		vec3 color;
		vec3 normal;
		vec3 albedo;
		float depth;
		raytracePrimSec(gl_GlobalInvocationID.xy, /*out*/ color,/*out*/ normal, /*out*/ albedo, /*out*/ depth, 1.0/float(indirectSamples));
		float packedAlbedo = uintBitsToFloat(//unlit
			uint(albedo.x*255)
			|
			(uint(albedo.y*255) << 8)
			|
			(uint(albedo.z*255) << 16)
		);
		imageStore(colorOutput, coord, vec4(color, packedAlbedo));
		imageStore(depthBuffer, coord, vec4(depth));
		imageStore(normalsBuffer, coord, vec4(normal, 0));
	}
	else
	{
		vec2 subpixelCoord = getSubpixelCoords(gl_GlobalInvocationID.xy, directSampleNum);
		int indirectSampleNum = sampleNum % indirectSamples;

		vec4 img = imageLoad(colorOutput, coord);
		vec3 color = img.xyz;
		if(indirectSampleNum > 0)
		{
			vec4 depthAndDirect = imageLoad(depthBuffer, coord);
			float depth = depthAndDirect.x;
			if(depth != 0)
			{
				vec4 normalAndDirect = imageLoad(normalsBuffer, coord);
				vec3 normal = normalAndDirect.xyz;

				// We will sample only secondary rays and use stored/prepared values from [indirectSampleNum==0]

				// Unpack direct values
				vec3 albedo;
				uint packedAlbedo = floatBitsToUint(img.w);
				albedo.x = float(packedAlbedo & 0xFF)/255;
				albedo.y = float((packedAlbedo >> 8) & 0xFF)/255;
				albedo.z = float((packedAlbedo >> 16) & 0xFF)/255;

				Ray cam = createCameraRay(subpixelCoord);
				vec3 origin = cam.origin + depth * cam.direction;
				raytraceSecondary(/*inout*/ color, /*in*/ origin, /*in*/ normal, /*in*/ albedo, 1.0/float(indirectSamples));
				imageStore(colorOutput, coord, vec4(color, img.w));
			}
		}
		else
		{
			vec3 newColor;
			vec3 normal;
			vec3 albedo;
			float depth;
			raytracePrimSec(subpixelCoord, /*out*/ newColor,/*out*/ normal, /*out*/ albedo, /*out*/ depth, 1.0/float(indirectSamples));
			float packedAlbedo = uintBitsToFloat(//unlit
				uint(albedo.x*255)
				|
				(uint(albedo.y*255) << 8)
				|
				(uint(albedo.z*255) << 16)
			);
			imageStore(colorOutput, coord, vec4(color + newColor, packedAlbedo));
			imageStore(depthBuffer, coord, vec4(depth));
			imageStore(normalsBuffer, coord, vec4(normal, 0));
		}
	}
}