//?#version 440
#include "Intersections.glsl"
#include "Structures.glsl"
#include "Common.glsl"

layout(local_size_x=16, local_size_y=16, local_size_z = 1) in;
layout(rgba32f, binding=0) writeonly uniform image2D opticalDepth;//r = rayleigh, g = mie, b = ozone
layout(std430, binding=1) readonly buffer PlanetBuffer
{
    Planet planets[];
};

void main()
{
	vec4 color;
	vec2 tc = vec2(gl_GlobalInvocationID.xy) / vec2(gl_WorkGroupSize * gl_NumWorkGroups);
	
	const Planet p = planets[0];
	float cosAlpha = tc.x*1.5-0.5;
	float sunToViewRayAngle = acos(cosAlpha);
	float sampleHeight = tc.y * p.atmosphereThickness + p.surfaceRadius;

	float x = sin(sunToViewRayAngle) * sampleHeight;
	float y = cosAlpha * sampleHeight;
	vec3 samplePos = vec3(x,y,0);

	int sampleCount = 500;
	float fromT,toT;
	raySphereIntersection(vec3(0), p.atmosphereRadius, Ray(samplePos, vec3(0,1,0)), fromT, toT);
	float lSegmentLength = toT / sampleCount;

	float tCurrentLight = 0;
	float lOpticalDepthR = 0,lOpticalDepthM = 0,lOpticalDepthO = 0;

	for (int l = 0; l < sampleCount; ++l) { 
		vec3 lSamplePos = samplePos + (tCurrentLight + lSegmentLength * 0.5) * vec3(0,1,0); 
		float lCenterDist = length(lSamplePos);
        float lSampleHeight /*above sea*/ = lCenterDist - p.surfaceRadius; 

        lOpticalDepthR += exp(-lSampleHeight / p.rayleighScaleHeight) * lSegmentLength;
		lOpticalDepthM += exp(-lSampleHeight / p.mieScaleHeight) * lSegmentLength; 
		lOpticalDepthO += ozoneHF(lSampleHeight, p, lSegmentLength);
		tCurrentLight += lSegmentLength; 
	}

	imageStore(opticalDepth, ivec2(gl_GlobalInvocationID.xy), vec4(lOpticalDepthR,lOpticalDepthM,lOpticalDepthO,0));
}