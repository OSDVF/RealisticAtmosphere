//?#version 440
#include "Intersections.glsl"
#include "SceneObjects.glsl"
#include "Common.glsl"
#include "Math.glsl"
#include "Terrain.glsl"

layout(local_size_x=16, local_size_y=16, local_size_z = 4) in;
layout(rgba32f, binding=0) writeonly uniform image3D scatteringOutput;

void main()
{
    vec3 texSize = vec3(gl_WorkGroupSize * gl_NumWorkGroups);
	vec3 frag_coord = vec3(gl_GlobalInvocationID.xyz + vec3(0.5));

	Planet planet = planets[0];
	float r;
	float mu; /*view to normal*/
	float mu_s; /*sun to normal*/
	float nu; /*sun to view*/
	bool terrainWasHit;
	GetRMuMuSNuFromScatteringTextureFragCoord(planet, frag_coord,
		r, mu, mu_s, nu, terrainWasHit);
	
	float viewToNormal = acos(mu);
	float sunToNormal = acos(mu_s);
	Ray ray = Ray(planet.center + vec3(0,r,0), vec3(sin(viewToNormal), mu, 0));

    // Number of intervals for the numerical integration.
    const int SAMPLE_COUNT = 50;

	// The integration step, i.e. the length of each integration interval.
	float segmentLength =
		DistanceToNearestAtmosphereBoundary(planet, r, mu,
			terrainWasHit) / float(SAMPLE_COUNT);

	vec3 rayleighColor = vec3(0);
	vec3 mieColor = vec3(0);
	float opticalDepthR = 0, opticalDepthM = 0, opticalDepthO = 0; 

	vec3 sunVector = vec3(sin(sunToNormal), mu_s, 0);

	float nu2 = nu * nu;

	float rayleightPhase = 3.0 / (16.0 * pi) * (1 + nu2);
	//There should be extinction coefficients, but for Rayleigh, they are the same as scattering coeff.s and for Mie, it is 1.11 times the s.c.
	float mieExtinction = 1.11 * planet.mieCoefficient;
	float assymetryFactor2 = planet.mieAsymmetryFactor * planet.mieAsymmetryFactor;
	float miePhase = 3.0 /
		(8.0 * pi) * ((1.0 - assymetryFactor2) * (1.0 + (nu2)))
		/ ((2.f + assymetryFactor2) * pow(1.0 + assymetryFactor2 - 2.0 * planet.mieAsymmetryFactor * nu, 1.5f));

	float currentDistance;
	float i = 0;//float iterator
	int iter = 0;//integer iterator
	for(currentDistance = 0; iter < SAMPLE_COUNT; currentDistance += segmentLength, iter++, i++)
	{
		// Always sample at the center of sample
		vec3 worldSamplePos;
		vec3 sphNormal;
		float sampleHeight = getSampleParameters(planet, ray, currentDistance + segmentLength * 0.5, /*out*/ sphNormal, /*out*/ worldSamplePos);

		//Compute HF = height factor
		float rayleighHF = exp(-sampleHeight/planet.rayleighScaleHeight) * segmentLength;
		float mieHF = exp(-sampleHeight/planet.mieScaleHeight) * segmentLength;
		opticalDepthO += ozoneHF(sampleHeight, planet, segmentLength);
		opticalDepthR += rayleighHF; 
        opticalDepthM += mieHF;

		//
		//Compute light optical depth
		//

        float lightFromT = 0, dummy, lightToT; 
		// Intersect light ray with outer shell of the planet
		Ray shadowRay = Ray(worldSamplePos, sunVector);
        raySphereIntersection(planet.center, planet.atmosphereRadius,
							shadowRay, dummy, lightToT);

		//Firstly check for object hits
		// Secondly check if sun is in shadow of the planet
		float sunToNormalCos = dot(sunVector, sphNormal);

		// The lookup table is from alpha angle value from -0.5 to 1.0, so we must remap the X coord
		vec2 tableCoords = vec2((0.5 + sunToNormalCos)/1.5, sampleHeight/(planet.atmosphereThickness));
		vec4 lOpticalDepth = texture(opticalDepthTable, tableCoords);
		//Finalize the computation and commit to the result color

		vec3 depth = planet.rayleighCoefficients * (lOpticalDepth.x + opticalDepthR)
						+ mieExtinction * (lOpticalDepth.y + opticalDepthM)
						+ planet.absorptionCoefficients * (lOpticalDepth.z + opticalDepthO);
		vec3 attenuation = exp(-depth);
		rayleighColor += attenuation * rayleighHF;
		mieColor += attenuation * mieHF;
	}

	imageStore(scatteringOutput, ivec3(gl_GlobalInvocationID.xyz), vec4(
			rayleighColor * planet.rayleighCoefficients * planet.solarIrradiance,
			mieColor.x * planet.mieCoefficient * planet.solarIrradiance 
		));
}