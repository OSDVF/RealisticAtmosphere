//?#version 440
#include "../../Common.glsl"
#include "PrecomputeSettings.glsl"

layout(local_size_x=16, local_size_y=16, local_size_z = 1) in;
layout(rgba32f, binding=0) writeonly uniform image2DArray indirectIrradianceOutput;
layout(std430, binding=1) readonly buffer PlanetBuffer
{
    Planet planets[];
};
uniform sampler3D singleScatteringTable;

void main()
{
	vec4 color;
    vec2 texSize = vec2(gl_WorkGroupSize * gl_NumWorkGroups);
    Planet planet = planets[0];
	vec2 frag_coord = (vec2(gl_GlobalInvocationID.xy) + 0.5f);
    float r, mu_s;
	GetRMuSFromIrradianceTextureUv(planet, frag_coord / texSize, r, mu_s, texSize);

	const int SAMPLE_COUNT = 32;
    const float dphi = pi / float(SAMPLE_COUNT);
    const float dtheta = pi / float(SAMPLE_COUNT);

    vec3 result = vec3(0.0);
    vec3 omega_s = vec3(sqrt(1.0 - mu_s * mu_s), 0.0, mu_s);
    for (int j = 0; j < SAMPLE_COUNT / 2; ++j) 
    {
        float theta = (float(j) + 0.5) * dtheta;
        for (int i = 0; i < 2 * SAMPLE_COUNT; ++i)
        {
            float phi = (float(i) + 0.5) * dphi;
            vec3 omega =
                vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));
            float domega = (dtheta) * (dphi) * sin(theta);

        float nu = dot(omega, omega_s);
        vec3 single_mie;
        vec3 rayleigh = GetCombinedScattering(planet, singleScatteringTable,
            r, omega.z, mu_s, nu, false /* ray_r_theta_intersects_ground */, float(gl_GlobalInvocationID.z), single_mie) *
                omega.z * domega * RayleighPhaseFunction(nu);

       result += rayleigh + single_mie * omega.z * domega * MiePhaseFunction(planet.mieAsymmetryFactor, nu);
    }
  }

	imageStore(indirectIrradianceOutput, ivec3(gl_GlobalInvocationID.xyz), vec4(result, 0));
}