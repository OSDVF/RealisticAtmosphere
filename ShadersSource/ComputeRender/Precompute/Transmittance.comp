//?#version 440
#include "../../Common.glsl"

layout(local_size_x=16, local_size_y=16, local_size_z = 1) in;
layout(rgba32f, binding=0) writeonly uniform image2D transmittanceOutput;
layout(std430, binding=1) readonly buffer PlanetBuffer
{
    Planet planets[];
};
vec2 texSize = vec2(gl_WorkGroupSize * gl_NumWorkGroups);

float ComputeOpticalLengthToTopAtmosphereBoundaryR(
    const Planet planet,
    float r, float mu) {
  // Number of intervals for the numerical integration.
  const int SAMPLE_COUNT = 500;
  // The integration step, i.e. the length of each integration interval.
  float dx =
      DistanceToTopAtmosphereBoundary(planet, r, mu) / float(SAMPLE_COUNT);
  // Integration loop.
  float result = 0.0;
  for (int i = 0; i <= SAMPLE_COUNT; ++i) {
    float d_i = float(i) * dx;
    // Distance between the current sample point and the planet center.
    float r_i = sqrt(d_i * d_i + 2.0 * r * mu * d_i + r * r);
    // Number density at the current sample point (divided by the number density
    // at the bottom of the atmosphere, yielding a dimensionless number).
    float y_i = exp(-(r_i - planet.surfaceRadius)/planet.rayleighScaleHeight);
    // Sample weight (from the trapezoidal rule).
    float weight_i = i == 0 || i == SAMPLE_COUNT ? 0.5 : 1.0;
    result += y_i * weight_i * dx;
  }
  return result;
}

float ComputeOpticalLengthToTopAtmosphereBoundaryM(
    const Planet planet,
    float r, float mu) {
  // Number of intervals for the numerical integration.
  const int SAMPLE_COUNT = 500;
  // The integration step, i.e. the length of each integration interval.
  float dx =
      DistanceToTopAtmosphereBoundary(planet, r, mu) / float(SAMPLE_COUNT);
  // Integration loop.
  float result = 0.0;
  for (int i = 0; i <= SAMPLE_COUNT; ++i) {
    float d_i = float(i) * dx;
    // Distance between the current sample point and the planet center.
    float r_i = sqrt(d_i * d_i + 2.0 * r * mu * d_i + r * r);
    // Number density at the current sample point (divided by the number density
    // at the bottom of the atmosphere, yielding a dimensionless number).
    float y_i = exp(-(r_i - planet.surfaceRadius)/planet.mieScaleHeight);
    // Sample weight (from the trapezoidal rule).
    float weight_i = i == 0 || i == SAMPLE_COUNT ? 0.5 : 1.0;
    result += y_i * weight_i * dx;
  }
  return result;
}

float ComputeOpticalLengthToTopAtmosphereBoundaryO(
    const Planet planet,
    float r, float mu) {
  // Number of intervals for the numerical integration.
  const int SAMPLE_COUNT = 500;
  // The integration step, i.e. the length of each integration interval.
  float dx =
      DistanceToTopAtmosphereBoundary(planet, r, mu) / float(SAMPLE_COUNT);
  // Integration loop.
  float result = 0.0;
  for (int i = 0; i <= SAMPLE_COUNT; ++i) {
    float d_i = float(i) * dx;
    // Distance between the current sample point and the planet center.
    float r_i = sqrt(d_i * d_i + 2.0 * r * mu * d_i + r * r);
    // Number density at the current sample point (divided by the number density
    // at the bottom of the atmosphere, yielding a dimensionless number).
    float y_i = ozoneHF(r_i - planet.surfaceRadius, planet, dx);
    // Sample weight (from the trapezoidal rule).
    float weight_i = i == 0 || i == SAMPLE_COUNT ? 0.5 : 1.0;
    result += y_i * weight_i;
  }
  return result;
}

vec3 ComputeTransmittanceToTopAtmosphereBoundary(
    const Planet planet, float r, float mu) {
  return exp(-(
      planet.rayleighCoefficients *
          ComputeOpticalLengthToTopAtmosphereBoundaryR(
              planet, r, mu) +
      1.11 * planet.mieCoefficient *
          ComputeOpticalLengthToTopAtmosphereBoundaryM(
              planet, r, mu) +
      planet.absorptionCoefficients *
          ComputeOpticalLengthToTopAtmosphereBoundaryO(
              planet, r, mu)));
}

vec3 ComputeTransmittanceToTopAtmosphereBoundaryTexture(
    const Planet planet, vec2 frag_coord) {
  float r;
  float mu;
  GetRMuFromTransmittanceTextureUv(
      planet, texSize, frag_coord, r, mu);
  return ComputeTransmittanceToTopAtmosphereBoundary(planet, r, mu);
}

void main()
{
	vec4 color;
	vec2 uv = (vec2(gl_GlobalInvocationID.xy) + 0.5f);
	
	vec3 result = ComputeTransmittanceToTopAtmosphereBoundaryTexture(planets[0], uv / texSize);

	imageStore(transmittanceOutput, ivec2(gl_GlobalInvocationID.xy), vec4(result, 0));
}