//!#version 440
#define COMPUTE 1
layout(local_size_x=16, local_size_y=16, local_size_z = 1) in;
#include "../raytracer.glsl"
layout(rgba16f, binding=0) uniform restrict image2D colorOutput;
layout(rgba16f, binding=1) uniform restrict image2D normalsBuffer;
layout(rg32f, binding=2) uniform restrict image2D depthBuffer;

void main()
{
	ivec2 coord = ivec2(gl_GlobalInvocationID.xy) + ivec2(CurrentChunk_x, CurrentChunk_y);
	int sampleNum = floatBitsToInt(HQSettings_sampleNum);
	int indirectSamples /*per every direct*/ = floatBitsToInt(Multisampling_indirect);
	int directSampleNum = sampleNum / indirectSamples;
	if(sampleNum == 0)
	{
		vec3 normal;
		vec3 albedo;//We call the initial throughput "albedo" because it consists only of first object albedo
		float depth;
		vec3 color = raytracePrimSec(coord, 1.0/float(indirectSamples),/*out*/ normal, /*out*/ albedo, /*out*/ depth);
		float packedAlbedo = uintBitsToFloat(//unlit
			uint(albedo.x*255)
			|
			(uint(albedo.y*255) << 8)
			|
			(uint(albedo.z*255) << 16)
		);
		imageStore(colorOutput, coord, vec4(color, 0));
		imageStore(normalsBuffer, coord, vec4(normal, 0));
		imageStore(depthBuffer, coord, vec4(depth, packedAlbedo, 0, 0 ));
	}
	else
	{
		vec2 subpixelCoord = getSubpixelCoords(coord, directSampleNum);
		int indirectSampleNum = sampleNum % indirectSamples;

		vec3 color = imageLoad(colorOutput, coord).xyz;
		if(indirectSampleNum > 0)
		{
			vec2 depthAndAlbedo = imageLoad(depthBuffer, coord).xy;
			float depth = depthAndAlbedo.r;
			if(depth != 0)
			{
				vec3 normal = imageLoad(normalsBuffer, coord).xyz;

				// We will sample only secondary rays and use stored/prepared values from sample where[indirectSampleNum==0]

				// Unpack direct values
				vec3 albedo;
				uint packedAlbedo = floatBitsToUint(depthAndAlbedo.g);
				albedo.x = float(packedAlbedo & 0xFF)/255;
				albedo.y = float((packedAlbedo >> 8) & 0xFF)/255;
				albedo.z = float((packedAlbedo >> 16) & 0xFF)/255;

				Ray cam = createCameraRay(subpixelCoord);
				vec3 origin = cam.origin + depth * cam.direction;
				raytraceSecondary(/*in*/ origin, /*in*/ normal, /*in*/ albedo, 1.0/float(indirectSamples), color);
				imageStore(colorOutput, coord, vec4(color, 0));
			}
		}
		else
		{
			vec3 normal;
			vec3 albedo;
			float depth;
			vec3 newColor = raytracePrimSec(subpixelCoord, 1.0/float(indirectSamples),/*out*/ normal, /*out*/ albedo, /*out*/ depth);
			float packedAlbedo = uintBitsToFloat(//unlit
				uint(albedo.x*255)
				|
				(uint(albedo.y*255) << 8)
				|
				(uint(albedo.z*255) << 16)
			);
			imageStore(colorOutput, coord, vec4(color + newColor, 0));
			imageStore(depthBuffer, coord, vec4(depth, packedAlbedo, 0, 0));
			imageStore(normalsBuffer, coord, vec4(normal, 0));
		}
	}
}